<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Juego jaja</title>
  <style>
    .game {
      display: grid;
      grid-template-columns: repeat(10, auto);
      width: 1036px;
      margin: 10px auto;
      background-color: #11213a;
      color: #04c0b2;
    }

    .winned {
      background-color: #FF0000;
    }

    .cell {
      font-family: "Permanent Marker", cursive;
      width: 100px;
      height: 100px;
      box-shadow: 2px 2px 2px 2px #ecd7ba;
      border: 2px solid #ecd7ba;
      cursor: pointer;
      line-height: 100px;
      font-size: 60px;
      text-align: center;
    }

    .cell-clicked {
      background-color: #b765be;
    }

    @keyframes shake {

      10%,
      90% {
        transform: translate3d(-1px, 0, 0);
      }

      20%,
      80% {
        transform: translate3d(2px, 0, 0);
      }

      30%,
      50%,
      70% {
        transform: translate3d(-4px, 0, 0);
      }

      40%,
      60% {
        transform: translate3d(4px, 0, 0);
      }
    }
  </style>
</head>

<body>
  <div class="game" id="game">
    <% for (let y=0 ; y < 10 ; y++) { %>
      <% for (let x=0 ; x < 10 ; x++) { %>
        <div onclick="onClick('<%=x%>', '<%=y%>')" class="cell" id="cell-<%- x %>-<%- y %>"></div>
        <% } %>
          <% } %>
  </div>
  <script>

    (function () {

      const CellStateEnum = {
        CLOSED: 0,
        OPEN: 1
      };

      const CellFlagEnum = {
        NONE: 0,
        EXCLAMATION: 1,
        QUESTION: 2
      };

      const BoardStateEnum = {
        PRISTINE: 0,
        IN_PROGRESS: 1,
        LOST: 2,
        WON: 3
      };

      class Cell {
        constructor(x, y, isMine, numAdjacentMines) {
          this.x = x || 0;
          this.y = y || 0;
          this.isMine = isMine ? true : false;
          this.numAdjacentMines = numAdjacentMines || 0;
          this.state = CellStateEnum.CLOSED;
          this.flag = CellFlagEnum.NONE;
        }
      }

      class Board {
        constructor(mineArray) {
          let isValid;

          try {
            isValid = isMineArrayValid(mineArray);
          } catch (e) {
            isValid = false;
          }

          if (!isValid) {
            throw new Error('The mine array supplied to Board constructor was not valid');
          }

          this._state = BoardStateEnum.PRISTINE;
          this._numRows = mineArray.length;
          this._numCols = mineArray[0].length;
          this._numMines = getNumMinesFromMineArray(mineArray, this._numRows, this._numCols);
          this._grid = generateGridFromMineArray(mineArray, this._numRows, this._numCols);
        }

        state() {
          return this._state;
        }

        numRows() {
          return this._numRows;
        };


        numCols() {
          return this._numCols;
        };

        numMines() {
          return this._numMines;
        };

        grid() {
          let i, j, clone = [];

          for (i = 0; i < this._numRows; i++) {
            clone.push([]);
            for (j = 0; j < this._numCols; j++) {
              clone[i].push(this.cell(j, i));
            }
          }

          return this._grid;
        };

        _cell(x, y) {
          if (x >= 0 && y >= 0 && y < this._numRows && x < this._numCols) {
            return this._grid[y][x];
          }
        };

        cell(x, y) {
          return extend({}, this._cell(+x, +y));
        };

        cycleCellFlag(x, y) {
          let cell = this._cell(+x, +y), updated = true;

          if (!cell || cell.state === CellStateEnum.OPEN ||
            this._state === BoardStateEnum.WON || this._state === BoardStateEnum.LOST) {
            return;
          }

          if (cell.flag === CellFlagEnum.NONE) {
            cell.flag = CellFlagEnum.EXCLAMATION;
          } else if (cell.flag === CellFlagEnum.EXCLAMATION) {
            cell.flag = CellFlagEnum.QUESTION;
          } else if (cell.flag === CellFlagEnum.QUESTION) {
            cell.flag = CellFlagEnum.NONE;
          } else {
            updated = false;
          }

          if (updated && this._state === BoardStateEnum.PRISTINE) {
            this._state = BoardStateEnum.IN_PROGRESS;
          }

          this._updateState();
        };

        openCell(x, y) {
          let cell = this._cell(x, y);

          if (!cell || cell.state === CellStateEnum.OPEN || cell.flag !== CellFlagEnum.NONE ||
            this._state === BoardStateEnum.WON || this._state === BoardStateEnum.LOST) {
            return;
          }

          cell.state = CellStateEnum.OPEN;

          if (!cell.isMine) {
            this._floodFill(x + 1, y);
            this._floodFill(x - 1, y);
            this._floodFill(x, y + 1);
            this._floodFill(x, y - 1);
            this._floodFill(x + 1, y + 1);
            this._floodFill(x - 1, y - 1);
            this._floodFill(x - 1, y + 1);
            this._floodFill(x + 1, y - 1);
          }

          if (this._state === BoardStateEnum.PRISTINE) {
            this._state = BoardStateEnum.IN_PROGRESS;
          }

          this._updateState();
        };

        _floodFill(x, y) {
          let cell = this._cell(x, y);

          if (cell && !cell.isMine && cell.state === CellStateEnum.CLOSED && cell.flag === CellFlagEnum.NONE) {
            cell.state = CellStateEnum.OPEN;

            if (cell.numAdjacentMines === 0) {
              this._floodFill(x + 1, y);
              this._floodFill(x - 1, y);
              this._floodFill(x, y + 1);
              this._floodFill(x, y - 1);
              this._floodFill(x + 1, y + 1);
              this._floodFill(x - 1, y - 1);
              this._floodFill(x - 1, y + 1);
              this._floodFill(x + 1, y - 1);
            }
          }
        };

        _updateState() {
          let x, y, cell, isWin = true;

          for (y = 0; y < this._numRows; y++) {
            for (x = 0; x < this._numCols; x++) {
              cell = this._cell(x, y);

              if (cell.state === CellStateEnum.OPEN) {
                if (cell.isMine) {
                  this._state = BoardStateEnum.LOST;
                  return;
                }
              } else if (cell.state === CellStateEnum.CLOSED) {
                if (cell.isMine) {
                  if (cell.flag !== CellFlagEnum.EXCLAMATION) {
                    isWin = false;
                  }
                } else {
                  isWin = false;
                }
              }
            }
          }

          if (isWin) {
            this._state = BoardStateEnum.WON;
          }
        };

      }

      function generateMineArray(options) {
        let i, j, length, rows, cols, mines, mineArray = [];

        options = options || {};
        rows = options.rows || 10;
        cols = options.cols || options.rows || 10;
        mines = options.mines || parseInt((rows * cols) * 0.15, 10) || 0;
        length = rows * cols;

        for (i = 0; i < length; i++) {
          if (i < mines) {
            mineArray.push(1);
          } else {
            mineArray.push(0);
          }
        }

        mineArray = fisherYatesShuffle(mineArray);
        mineArray = singleToMultiDimensionalArray(mineArray, cols);

        return mineArray;
      };

      function generateGridFromMineArray(mineArray, numRows, numCols) {
        const grid = [];

        for (let y = 0; y < numRows; y++) {
          grid[y] = [];
          for (let x = 0; x < numCols; x++) {
            grid[y][x] = new Cell(
              x,
              y,
              mineArray[y][x] === 1 ? true : false,
              getNumAdjacentMineCount(mineArray, x, y)
            );
          }
        }

        return grid;
      };

      function getNumMinesFromMineArray(mineArray, numRows, numCols) {
        let mineCount = 0;

        for (let y = 0; y < numRows; y++) {
          for (let x = 0; x < numCols; x++) {
            if (mineArray[y][x] === 1) {
              mineCount++;
            }
          }
        }

        return mineCount;
      };

      function getNumAdjacentMineCount(mineArray, x, y) {
        const endX = x + 1,
          endY = y + 1,
          maxX = mineArray[0].length,
          maxY = mineArray.length;
        let mineCount = 0;

        for (let idxY = y - 1; idxY <= endY; idxY++) {
          for (let idxX = x - 1; idxX <= endX; idxX++) {
            if (idxY !== y || idxX !== x) {
              if (idxY >= 0 && idxX >= 0 && idxY < maxY && idxX < maxX) {
                if (mineArray[idxY][idxX] === 1) {
                  mineCount++;
                }
              }
            }
          }
        }

        return mineCount;
      };

      function isMineArrayValid(mineArray) {
        let rows, columns, isValid = true;

        if (mineArray && mineArray.length) {
          rows = mineArray.length;
          columns = mineArray[0] ? mineArray[0].length : 0;

          if (columns === 0) {
            isValid = false;
          }

          for (let rowIdx = 0; rowIdx < rows; rowIdx++) {
            if (mineArray[rowIdx].length !== columns) {
              isValid = false;
            } else {
              for (let colIdx = 0; colIdx < columns; colIdx++) {
                if (mineArray[rowIdx][colIdx] !== 0 && mineArray[rowIdx][colIdx] !== 1) {
                  isValid = false;
                }
              }
            }
          }
        } else {
          isValid = false;
        }

        return isValid;
      };

      function fisherYatesShuffle(array) {
        let m = array.length, t, i;

        while (m) {
          i = Math.floor(Math.random() * m--);
          t = array[m];
          array[m] = array[i];
          array[i] = t;
        }

        return array;
      };

      function singleToMultiDimensionalArray(array, numCols) {
        const rows = array.length / numCols,
          multi = [];

        for (let i = 0; i < rows; i++) {
          multi.push(array.splice(0, numCols));
        }

        return multi;
      };

      function extend(defaults, options) {
        let extended = {};
        for (let prop in defaults) {
          if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
            extended[prop] = defaults[prop];
          }
        }
        for (let prop in options) {
          if (Object.prototype.hasOwnProperty.call(options, prop)) {
            extended[prop] = options[prop];
          }
        }
        return extended;
      };

      const minesweeper = {
        Cell: Cell,
        CellStateEnum: CellStateEnum,
        CellFlagEnum: CellFlagEnum,
        Board: Board,
        BoardStateEnum: BoardStateEnum,
        generateMineArray: generateMineArray
      };

      if (typeof define === 'function' && define.amd) {
        define([], function () {
          return minesweeper;
        });
      }
      else {
        window.minesweeper = minesweeper;
      }
    })();
    const mineArray = minesweeper.generateMineArray({
      rows: 10,
      cols: 10,
      mines: 10
    });
    const board = new minesweeper.Board(mineArray);
    updateBoard();

    function onClick(x, y) {
      x = Number(x);
      y = Number(y);
      console.log(x, y);
      console.log(board.state(), 'state');
      if (board.state() === minesweeper.BoardStateEnum.LOST) return;
      board.openCell(x, y);
      updateBoard();
      if (board.state() === minesweeper.BoardStateEnum.LOST) {
        const cells = [];
        for (let _y = 0; _y < 10; _y++) {
          for (let _x = 0; _x < 10; _x++) {
            const cell = board.cell(_x, _y);
            if (cell.isMine) {
              cells.push(`${_x},${_y}`);
            }
          }
        }
        for (let i = 0; i < cells.length; i++) {
          const [_x, _y] = cells[i].split(',');
          const cellDiv = document.getElementById(`${_x},${_y}`);
          cellDiv.style.animation = "shake 1s linear";
        }
        console.log('you lost');
      } else if (board.state() === minesweeper.BoardStateEnum.WON) {
        console.log('you won');
      }
    }

    function rightClick(x, y) {
      x = Number(x);
      y = Number(y);
      console.log(x, y, 'xd');
      board.cycleCellFlag(x, y);
      updateBoard();
    }

    function updateBoard() {
      const canShow = [
        minesweeper.BoardStateEnum.PLAYING,
        minesweeper.BoardStateEnum.WON,
        minesweeper.BoardStateEnum.LOST
      ].includes(board.state());
      const game = document.getElementById('game');
      let txt = '';
      for (let y = 0; y < 10; y++) {
        for (let x = 0; x < 10; x++) {
          const cell = board.cell(x, y);
          if (!canShow) {
            if (cell.isMine && cell.state === minesweeper.CellStateEnum.OPEN) {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">üí£</div>`;
            } else if (cell.flag === minesweeper.CellFlagEnum.EXCLAMATION) {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">üö©</div>`;
            } else if (cell.flag === minesweeper.CellFlagEnum.QUESTION) {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">‚ùì</div>`;
            } else if (!cell.isMine && cell.state === minesweeper.CellStateEnum.OPEN) {
              txt += `<div class="cell cell-clicked" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">${cell.numAdjacentMines}</div>`;
            } else {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')"></div>`;
            }
          } else {
            game.className = 'game winned'
            if (cell.isMine) {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">üí£</div>`;
            } else if (cell.flag === minesweeper.CellFlagEnum.EXCLAMATION) {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">üö©</div>`;
            } else if (cell.flag === minesweeper.CellFlagEnum.QUESTION) {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">‚ùì</div>`;
            } else {
              txt += `<div class="cell" id="${x},${y}" oncontextmenu="rightClick('${x}', '${y}')" onclick="onClick('${x}', '${y}')">${cell.numAdjacentMines}</div>`;
            }
          }
        }
      }
      game.innerHTML = txt;
    }
    window.oncontextmenu = function () {
      return false;
    }
  </script>
</body>

</html>